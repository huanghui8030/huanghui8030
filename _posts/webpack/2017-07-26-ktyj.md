---
layout: post
title:  "webpack课题研究"
date:   2017-07-26 16:42:19 +0800
categories: webpack
sort: 0802
---

## 一、什么是webpack

### 1.1 、基本概念

本质上，*webpack* 是一个现代 JavaScript 应用程序的*模块打包器(module bundler)*。当 webpack 处理应用程序时，它会递归地构建一个*依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle*。                                                                                                                                                                     

- 模块化，让我们可以把复杂的程序细化为小的文件，便于公用；
- WebPack可以看做是**模块打包机**：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Less，ES6等），并将其打包为合适的格式以供浏览器使用。
- Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。

### 1.2 WebPack与Gulp区别

- 其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。
- Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。
- Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。
- 如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。

## 二、安装和配置

### 2.1 安装

- 全局安装：` cnpm install webpack -g`

- 项目依赖：`npm install webpack --save-dev`

- 项目初始化：`cnpm init`

  ​

### 2.2 配置

- 每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js。就是一个配置项，告诉 webpack 它需要做什么。

- 示例：

  ```javascript
  var webpack = require('webpack');
  var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');

  module.exports = {
      //插件项
      plugins: [commonsPlugin],
      //页面入口文件配置
      entry: {
          index : './src/js/page/index.js'
      },
      //入口文件输出配置
      output: {
          path: 'dist/js/page',
          filename: '[name].js'
      },
      module: {
          //加载器配置
          loaders: [
              { test: /\.css$/, loader: 'style-loader!css-loader' },
              { test: /\.js$/, loader: 'jsx-loader?harmony' },
              { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
              { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
          ]
      },
      //其它解决方案配置
      resolve: {
          root: 'E:/github/flux-example/src', //绝对路径
          extensions: ['', '.js', '.json', '.scss'],
          alias: {
              AppStore : 'js/stores/AppStores.js',
              ActionType : 'js/actions/ActionType.js',
              AppAction : 'js/actions/AppAction.js'
          }
      }
  };
  ```

- （1）plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。

- （2）entry 是页面入口文件配置，output 是对应输出项配置*（即入口文件最终要生成什么名字的文件、存放到哪里）*，其语法大致为：

  ```javascript
  {
      entry: {
          page1: "./page1",
          //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出
          page2: ["./entry1", "./entry2"]
      },
      output: {
          path: "dist/js/page",
          filename: "[name].bundle.js"
      }
  }
  ```

- 该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。

- （3）module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：

  ```javascript
  module: {
          //加载器配置
          loaders: [
              //.css 文件使用 style-loader 和 css-loader 来处理
              { test: /\.css$/, loader: 'style-loader!css-loader' },
              //.js 文件使用 jsx-loader 来编译处理
              { test: /\.js$/, loader: 'jsx-loader?harmony' },
              //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理
              { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
              //图片文件使用 url-loader 来处理，小于8kb的直接转为base64
              { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
          ]
      }
  ```

- 注意所有的加载器都需要通过 npm 来加载

- （4）最后是 resolve 配置，这块很好理解，直接写注释了：

  ```javascript
  resolve: {
          //查找module的话从这里开始查找
          root: 'E:/github/flux-example/src', //绝对路径
          //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名
          extensions: ['', '.js', '.json', '.scss'],
          //模块别名定义，方便后续直接引用别名，无须多写长长的地址
          alias: {
              AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可
              ActionType : 'js/actions/ActionType.js',
              AppAction : 'js/actions/AppAction.js'
          }
      }
  ```

  ​

## 三、运行webpack



## 四、模块引入

### 4.1 HTML

- 直接在页面引入打包后的js即可。连样式都不用引入，脚本执行时会动态生成<style>并标签打到head里。

  ```html
  <!DOCTYPE html>
  <html>
  <head lang="en">
    <meta charset="UTF-8">
    <title>demo</title>
  </head>
  <body>
    <script src="dist/js/page/common.js"></script>
    <script src="dist/js/page/index.js"></script>
  </body>
  </html>
  ```

- ​

### 4.2 JS

- ​

### 4.3 执行webpack

- 局部webpack，执行：`node_modules/.bin/webpack src/main.js js/bundle.js`
- package.json来设置。
- 通过package.json中的脚本部分已经默认在命令前添加了`node_modules/.bin`路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。

## 参考文档

- http://www.jianshu.com/p/42e11515c10f


- [彻底解决Webpack打包性能问题](https://zhuanlan.zhihu.com/p/21748318)



> huangh 20170726