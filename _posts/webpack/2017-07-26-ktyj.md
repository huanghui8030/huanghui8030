---
layout: post
title:  "webpack课题研究"
date:   2017-07-26 16:42:19 +0800
categories: webpack
sort: 0802
---

针对webpack的课题研究，根据一下内容进行编写ppt，该文章为ppt的基础，当实际PPT中会有一些删减，具体以ppt为主，该文章只是辅助作用。具体从一下几个方面进行讲解：

- webpack的简介

  - webpack是什么


  - webpack与gulp、browserify的关系
  - webpack的应用场景
  - webpack的特性
- webpack基本用法

  - 安装
  - 基本配置
  - 模块引入HTML
  - webpack命令行
- webpack参数配置

  - entry和output
  - loaders
  - plugins
  - 其他配置
- webpack实际应用
- 参考文档

## 一、webpack的简介

### 1.1 webpack是什么

本质上，*webpack* 是一个现代 JavaScript 应用程序的*模块打包器(module bundler)*。当 webpack 处理应用程序时，它会递归地构建一个*依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle*。                                                                                                                                                                     

- 模块化，让我们可以把复杂的程序细化为小的文件，便于公用；
- WebPack可以看做是**模块打包机**：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Less，ES6等），并将其打包为合适的格式以供浏览器使用。
- Webpack 是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。

### 1.2 webpack与gulp、browserify的关系

#### （1）webpack与gulp本质不同

- 其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。
- Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。
- Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。

#### （2）webpack与gulp相同点

- webpack与gulp相同点：让各类语言变成浏览器可识别的语言。
- Webpack的处理速度更快更直接，能打包更多不同类型的文件。

#### （3）webpack与gulp区别总结

- 无可比性，不过webpack的优点使得webpack可以替代gulp/grunt类的工具。无可比性，不过webpack的优点使得webpack可以替代gulp/grunt类的工具。
- 如果实在要把二者进行比较，webpack的处理速度更快更直接，能打包更多不同类型的文件。

#### （4）webapck是一种js模块化解决方案

- seajs/requirejs：一个在线"编译" 模块的方案。相当于在页面上加载一个 CMD/AMD 解释器，让浏览器识别 define、exports、module 这些东西，也就实现了模块化。
- webpack/browserify ：一个预编译模块的方案。这个方案更加智能。预编译，本地直接写js。不管是 AMD / CMD / ES6 风格的模块化，它都能认识，并且编译成浏览器认识的JS。

#### （5）webpack与browserify、gulp三者之间的关系

- gulp是一个工具，旨在规范前端开发流程。
- webpack是模块化方案，更加强调模块化开发。
- gulp也可以配置seajs、requirejs甚至webpack的插件。

### 1.3 Webpack应用场景

#### （1）疑问

- webpack只适合前后端分离的项目结构吗？
- webpack适合多页面的项目构建吗？

#### （2）解答

- webpack跟前后端分离没关系。只要配置得到，可以实现前后端分离。
- 适合多页面的项目构建。

#### （3）应用

- 常用于vue和react等项目中，需要了解；
- 可用处插件开发，进行模块处理。

### 1.4 webpack的特性

- webpack能更好的落实到业务，提高开发效率


- 一切皆模块，即代码分割：
  - 正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以`require('myJSfile.js')`亦可以`require('myCSSfile.css')`。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。
- 按需加载，懒加载：
  - 传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的`bundle.js`文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。
- 同时可以用到nodejs中的require和export等语法，快速便捷。

## 二、基本用法

### 2.1 安装

- 全局安装：` cnpm install webpack -g`
- 项目依赖：`cnpm install webpack --save-dev`
- 项目初始化：`cnpm init`

### 2.2 基本demo

#### 流程

- 页面：index.html

  ```html
  <!DOCTYPE html>
  <html>
  <head lang="en">
    <meta charset="UTF-8">
    <title>demo</title>
  </head>
  <body>
    <script src="build/hello.build.js"></script>
  </body>
  </html>
  ```

- 脚本：hello.js

  ```js
  /**
   * 只通过命令行来压缩js
   * 依赖：cnpm install webpack --save-dev
   * 执行： webpack hello.js build/hello.build.js
   */
  a();
  function a(){
      alert('hello.js');
  }
  ```

- 依赖：cnpm install webpack --save-dev

- 执行命令行： webpack hello.js build/hello.build.js

#### 说明

- 直接在页面引入打包后的js即可。连样式都不用引入，脚本执行时会动态生成`<style>`并标签打到head里。
- 根据需要也可以将css单独放到一个css文件中。

### 2.3 webpack命令行

- 局部webpack，执行：`node_modules/.bin/webpack src/main.js js/bundle.js`
- package.json来设置。
- 通过package.json中的脚本部分已经默认在命令前添加了`node_modules/.bin`路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。

```javascript
webpack         // 最基本的启动webpack的方法
webpack -w      // 提供watch方法；实时进行打包更新
webpack -p      // 对打包后的文件进行压缩
webpack -d      // 提供source map，方便调式代码

```
- --watch | -w：热更新
- -p：打包文件压缩
- --progress：打包过程，中间有进度。
- --display-modules：打包中的所有文件
- --display-reasons：打包原因


- --module-bin：css引入时，不用加载loader，则命令行需要修改
  - 如果把test.css中的文件引入修改一下，require(‘style-loader!css-loader!./test.css');  改成   require(‘./test.css')
  - 则，命令行执行时，需要改成：webpack src/test.js bulid/index.js --module-bind 'css=style-loader!css-loader'


- --config：指定打包文件
  - webpack --config webpack.config.js，需要新建配置文件
  - 解决什么？       解决了开发和发布不同的环境的问题
  - 在哪配置呢？   package.jspn文件中的scripts项配置
  - 如何启动呢？   其在终端执行的方式有些不同，分两种情况：
    - start命令：cnpm start
    - 其他name命令：cnpm run name 

## 三、webpack参数配置

### 3.1 配置文件webpack.config.js

- 新建配置文件：webpack.config.js或者是webpack.config.othername.js，一个或者多个均可。

- 示例：

  ```javascript
  var webpack = require('webpack');
  var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');

  module.exports = {
      //页面入口文件配置
      entry: {
          index : './src/js/page/index.js'
      },
      //入口文件输出配置
      output: {
          path: 'dist/js/page',
          filename: '[name].js'
      },
      module: {
          //加载器配置
          loaders: [
              { test: /\.css$/, loader: 'style-loader!css-loader' },
              { test: /\.js$/, loader: 'jsx-loader?harmony' },
              { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
              { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
          ]
      },
      //插件项
      plugins: [commonsPlugin],
      //其它解决方案配置
      resolve: {
          root: 'E:/github/flux-example/src', //绝对路径
          extensions: ['', '.js', '.json', '.scss'],
          alias: {
              AppStore : 'js/stores/AppStores.js',
              ActionType : 'js/actions/ActionType.js',
              AppAction : 'js/actions/AppAction.js'
          }
      }
  };
  ```

####（1）名称

- 每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js。就是一个配置项，告诉 webpack 它需要做什么。

####（2）主要配置项：

- entry 是页面入口文件配置。

- output 是对应输出项配置。

- module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理。

- plugins 是插件项。

  ​

####（3）其他配置

- resolve 辅助配置。
- devtool  开发时使用，能够较快识别源文件。
- devServer 启动本地服务


 ### 3.2 entry和output

webpack 的配置中主要的两个配置 key 是，entry 和 output。

```javascript
{
    entry: [String | Array | Object], // 入口模块
    output: {
        path: String,      // 输出路径
        filename: String   // 输出名称或名称 
        publicPath: String // 指定静态资源的位置
        ...                // 其他配置
    }
}
```

#### （1）单一入口

如果只有一个入口文件，可以有如下几种配置方式：

```javascript
// 第一种 String 
{
  	entry: __dirname +'/static/js/a.js',
    output: {
        filename:  './dist/js/bundle.js'
    }
}

// 第二种 Array 
{
    entry: [__dirname +'/static/js/a.js',__dirname +'/static/js/b.js'],
    output: {
        path:__dirname +'/dist/js/',
        filename: 'bundle.js'
    }
}

// 第三种 Object
{
  entry: {
    ajs: './src/.a.js',
    bjs:'./src/b.js'
  },
  output: {
    path: './dist/',
    filename: 'index.js'
  }
}
```

#### （2）多文件入口

当存在多个入口时 ，可以使用 Array 的方式，比如依赖第三方库 bootstrap ，最终 bootstrap 会被追加到打包好的 index.js 中，数组中的最后一个会被 export。

```javascript
{
  entry: ['./src/index.js', './vendor/bootstrap.min.js'],
  output: {
    path: './dist',
    filename: "index.js"
  }
}
```

#### （3）多个打包目标文件

上面的例子中都是打包出一个 index.js 文件，如果项目有多个页面，那么需要打包出多个文件，webpack 可以用对象的方式配置多个打包文件

```javascript
{
  entry: {
    index: './src/index.js',
    a: './src/a.js'
  },
  output: {
    path: './dist/',
    filename: '[name].js' 
  }
}
```

最终会打包出：

```javascript
.
├── a.js
└── index.js
```



#### （4） output参数说明

- 文件名称 filename
  - [name] entry 对应的名称
  - [hash] webpack 命令执行结果显示的 Hash 值
  - [chunkhash] chunk 的 hash，为了让编译的结果名称是唯一的，可以利用 hash 。
- 常用参数：
  - output.filename 生成的文件名模板，比如 "[name].bundle.js"
  - output.path 生成的文件目录，绝对路径
  - output.publicPath 线上静态资源目录
  - output.chunkFilename 代码块文件名模板
  - output.sourceMapFilename source-map文件名模板。默认是[file].map
  - output.jsonpFunction JSONP异步加载代码块（chunk）时JSONP函数名，默认是webpackJsonp 
  - output.hotUpdateFunction JSONP异步热更新代码块时JSONP函数名，默认是webpackHotUpdate
  - output.pathinfo 是否以注释形式在require中增加模块path信息
  - output.library bundle作为库输出，值为库名
  - output.libraryTarget 输出库的格式。比如可选amd，umd，commonjs等

### 3.3 loaders

module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理。

#### （1）loaders作用

- 它告知 webpack 每一种文件都需要使用什么加载器来处理。
- 将各种文件类型转为webpack可识别的js文件类型。

####（2）loaders安装

- 所有的加载器都需要通过 npm 来加载
- 例如：cnpm install less-loader —save-dev

#### （3）loader 功能

- loader 管道：在同一种类型的源文件上，可以同时执行多个 loader ， loader 的执行方式可以类似管道的方式，管道执行的方式是从右到左的方式loader 可以支持同步和异步
- loader 可以接收配置参数
- loader 可以通过正则表达式或者文件后缀指定特定类型的源文件
- 插件可以提供给 loader 更多功能
- loader 除了做文件转换以外，还可以创建额外的文件

#### （4）loader配置

- 一个loader配置如下：

```javascript
{
    // 通过扩展名称和正则表达式来匹配资源文件
    test: String ,          
    // 匹配到的资源会应用 loader， loader 可以为 string 也可以为数组
    loader: String | Array
}
```

- 常用loader配置

  #####	webpack 2.0

```javascript
module: {
        //加载器配置
        loaders: [
            //.css 文件使用 style-loader 和 css-loader 来处理
            { test: /\.css$/, loader: 'style-loader!css-loader' },
            //.js 文件使用 jsx-loader 来编译处理
            { test: /\.js$/, loader: 'jsx-loader?harmony' },
            //.scss 文件使用 style-loader、css-loader 和 less-loader 来编译处理
            { test: /\.les$/, loader: 'style!css!less?sourceMap'},
            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64
            { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
        ]
    }
```

#####   		webpack 3.0	

```js
 module: {
        rules: [{   
          test: /\.(png|gif|svg)$/,
          use: [{
            loader: 'url-loader',//转成base64格式图片
            options: {limit: 2000}
        }]},{
           test: /\.(jpg)$/,
           use: [{
             loader: 'file-loader',
             options:{name: 'images/[name].[ext]?[hash:8]'}
        }]}
 ]}
```



- 所有loader都可以配置以下项目：
  - test 用来对文件名进行匹配测试
  - exclude 被排除的文件名
  - include 包含的文件名
  - loader 叹号分割的loaders
  - loaders loader数组
- 安装loader
  - 注意所有的加载器都需要通过 npm 来加载，例如：**npm install sass-loader --save-dev**（具体见下章节）

####（5）样式相关loader配置：

-  style-loader：将css样式以style的方式加载到脚本文件中，样式起作用。 
-  css-loader：css文件可以直接作为模块加载到其他脚本文件中。
  - options.modules：true，将css文件作为局部变量。
    - css-loader：局部设置
  - postcss-loader：兼容性，加厂商前缀。
    需要新建一个配置文件，postcss.config.js
-  less-loader：将less/scss文件转为css文件
  - strictMath，是否严格匹配
  - noIeCompat，是否不兼容ie
  - 注意顺序，从后往前
    其他文件类型类似，例如：sass-loader、json-loader、svg-online-loader、mocha-loader、babel-loader
#### （6）图片相关配置，file-loader和url-loader
-  file-loader：文件加载器
-  url-loader：将指定格式的文件，转为base64格式图片



### 3.4 plugins插件项

####（1）plugins是什么

- webpack 提供插件机制，可以对每次 build 的结果进行处理。

####（2）plugins与loader的区别

- loaders和plugins常常被弄混，但是他们其实是完全不同的东西：
  - loaders是在打包构建过程中用来处理源文件的（jsx，scss，less..），一次处理一个，一类文件；
  - plugins插件并不直接操作单个文件，它直接对整个构建过程其作用。

####（3）plugins分类

- 内置插件：webpack内置方法，不需要安装依赖包，直接通过webpack.BannerPlugin直接使用。
  - BannerPlugin
  - HotModuleReplacementPlugin
- 第三方插件：需要安装npm依赖包，cnpm install html-webpack-plugin —save-dev。

  - html-webpack-plugin
  - extract-text-webpack-plugin
  - clean-webpack-plugin

####（4）plugins使用方法

- 配置 plugins 的方法为在 webpack.config.js 中添加
- webpack 提供插件机制，可以对每次 build 的结果进行处理。
- plugins可以携带参数/选项，向plugins属性传入new实例。常见配置如下：

```javascript
{
  plugins: [
   new BellOnBundlerErrorPlugin()
  ]
}
```

- plugin 也是一个 npm 模块，安装一个 plugin ：

```javascript
$ npm install bell-on-bundler-error-plugin --save-dev
```

#### （5）插件详解：添加版权注释

- webpack插件内置方法
- 直接在plugins中使用，直接new一个对象，通过webpack直接调用。
- new webpack.BannerPlugin(‘我是一行注释！')

####（6）插件详解：html模板

- 安装npm包： html-webpack-plugin
- 在配置文件webpack.config.js的plugin中new一个对象：new HtmlWebpackPlugin({options})。

- 参数详解：
  - title：标题
  - filename：生成的html文件
  - inject：”true |body | header ”，js引入的位置。默认true，并且true和body一样，都放到底部。
  - hash：添加hash值，去缓存
  - template：添加自定义模板

####（6）插件详解：html模板

- - 默认不加配置时，直接生成一个html页面，只引用output中的js。
  - webpack.config.js的plugins中增加：new HtmlWebpackPlugin()
  - 生成的html模板页面：index.html
  - 参数讲解：

####（7）插件详解，单独提取css

- 安装npm包：extract-text-webpack-plugin

####（8）插件详解，清除生成的文件

- 安装npm包：clean-webpack-plugin
- clean-webpack-plugin参数说明
  - root，默认__dirname，一个根的绝对路径。
  - verbose，默认：true，将log写到 console。
  - dry，默认：false。删除文件，为true则不删除，主要用于测试。
  - watch，默认：false。为true则只删除重新编译的文件。
  - exclude，排除不删除的目录，主要用于避免删除公用的文件。
  - allowExternal，默认：false  - 不允许在webpack根目录之外的干净的文件夹。

### 3.5 其他配置配置

#### （1） resolve 配置：

- resolve.alias 模块别名


- resolve.root 模块根目录，绝对路径
- resolve.modulesDirectories 模块目录，工作方式类似node_modules。默认值是["web_modules", "node_modules"]
- resolve.fallback 如果在root和modulesDirectories都找不到，会在这里搜索
- resolve.extensions 用于模块查找的扩展名。
- resolve.packageMains
- resolve.packageAlias
- resolve.unsafeCache

直接写注释了：

```javascript
resolve: {
        //查找module的话从这里开始查找
        root: 'E:/github/flux-example/src', //绝对路径
        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名
        extensions: ['', '.js', '.json', '.scss'],
        //模块别名定义，方便后续直接引用别名，无须多写长长的地址
        alias: {
            AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可
            ActionType : 'js/actions/ActionType.js',
            AppAction : 'js/actions/AppAction.js'
        }
    }
```

####（2）devtool：eval-source-map| source-map

- 开发时使用，便于调试。
- 其中source-map是最详细的，但构建速度慢。

####（3）devServer，启动本地服务

- proxy，端口号等设置
- compress，是否进行gzip压缩
- historyApiFallback，404页面是否显示在页面。
- hot，是否热更新，
- noInfo，只有errors 或者是warns时才重新刷新。

### 3.6 webpack参数配置小结

- 配置文件webpack.config.js
- entry和outer，入口/出口配置
  - entry，三种情况String、Array、Object。
  - output，可多个目标输出，也可进行资源替换。
- loaders 加载器配置
  - loaders作用、安装、使用，以及功能。
  - 具体实例，样式和图片相关实例
- plugins 插件配置
  - plugins概率，与loaders区别，分类，以及使用方法。
  - 具体实例：添加注释、html模板、单独提取css、清楚冗余文件。
- resolve 其他配置
  - resolve、devtool、devServer等配置项

## 三、webpack实际应用

### 4.1 webpack+vue
- Vue是一套用于构建用户界面的渐进式框架
- Vue.js的特性：轻量级的框架、双向数据绑定、指令、插件化。
- 有自己的webpack脚手架（建议用，不用自己设置）：vue-cli。
- 用vue-cli来搭建一个项目
  - nam install -g vue-cli
  - vue init webpack my-project
  - cd my-project
  - npm install
  - npm run dev
  - 启动服务后，在浏览器中输入：<http://localhost:8080>
  - 在项目下面的src/App.vue和src/main.js中输入自己的代码即可。
### 4.2 webpack+react

- React是目前非常热门的一个JavascriptMVC框架。

- 主要以虚拟DOM而闻名。

- 组件化、易复用解耦、数据控制视图 、没有太多api，知道对应的写作模式就可以上手。

- 与webpack结合是标配。

- webpack+react实例

  - 需要安装的npm包，以及路径。
  - 新建main.jsx文件

### 4.3 webpack+gulp

- 前端工程化；更好的管理前端代码；同时符合现有项目配置

- gulp：处理html压缩/预处理/条件编译，图片压缩，图片自动合并等任务；
- webpack：管理模块化，构建js/css。

```js
//引入js 模块化工具gulp-webpack,
var webpack = require('gulp-webpack');
var jsFiles = ['./src/scripts/app.js'];
gulp.task('packjs',function () {
    gulp.src(jsFiles)
    .pipe(webpack({
        output:{
            filename:'[name].js'
        },
        module:{
            loaders:[
                {
                    test:/\.js$/,
                    loader:'imports?define=>false'
                }
            ]
        }
    }))
    .pipe(gulp.dest('./build/prd/scripts/'))
})
```



## 总结

- webpack简介

  - 基本概率、与gulp的详细区别、应用场景，以及特性。

- webpack安装和执行

  - 如何安装、简单demo，以及命令行用法。

- webpack参数配置

  - 主要参数配置：entry、output、loaders、plugins
  - 其他参数配置：resolve、devtool、devServer等配置项
- webpack应用

  - 与vue、webpack等框架的应用实例
  - 与gulp相互结合使用的应用实例



## 参考文档

- [webpack官方网址](https://webpack.js.org/)
- [入门Webpack，看这篇就够了](http://www.jianshu.com/p/42e11515c10f)


- [彻底解决Webpack打包性能问题](https://zhuanlan.zhihu.com/p/21748318)
- [前端工程与模块化框架](https://github.com/fouber/blog/issues/4)
- [gulp+webpakc构建多页面前端项目](https://segmentfault.com/a/1190000003969465)
- [【webpack】流行的前端模块化工具webpack初探](http://www.cnblogs.com/penghuwan/p/6665140.html)



> huangh 20170726 -20180115

